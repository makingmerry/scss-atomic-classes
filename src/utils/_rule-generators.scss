// # Rule generators
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////

// # Breakpoints
//
// @global:
// $breakpoint-step
////////////////////////////////////////
////////////////////////////////////////

// Core mixin, compose base rule with @media-query block if necessary.
@mixin breakpoint($map, $size) {
  @if $size == base {
    @content;
  } @else {
    @media (min-width: map-get($map, $size)) {
      @content;
    }
  }
}

// Constructs media-query rules with a map of breakpoints.
@mixin breakpoint-rules($map) {
  @for $i from 0 through length($map) {
    $size: base;
    // Undesirable, but expose mixin variables to the global scope
    // so @content can access them when composing rules.
    $breakpoint-step: "" !global;

    // Compose base rules with @media-query blocks.
    @if $i != 0 {
      $size: nth(map-keys($map), $i);
      $breakpoint-step: "--" + str-slice($size, 0, 1) !global;
    }

    @include breakpoint($map, $size) {
      @content;
    }
  }
}

// # Index
//
// Takes in a `Map` param of options,
// then generates and exposes (to the global scope) variables to @content
//
// e.g.
// $map: (
//   "base-val": 1em,
//   "ratio": 2,
//   "counts": 3,
// );
// .m-top-1 { margin-top: 1em }
// .m-top-2 { margin-top: 2em }
// .m-top-3 { margin-top: 4em }
//
// @params:
// $map `Map`:
// - $base-val `Num + (?unit)`: starting value
// - $counts `Int`: total count in loop (excluding negative values)
// - $ratio `Num`: ratio of next value in loop
//
// @global-vars:
// $index-mod:  "-" + $step !global;
////////////////////////////////////////
////////////////////////////////////////

// Helper function to determine next value in index
@function index-val($base-val, $count, $ratio) {
  @return pow($ratio, $count - 1) * $base-val;
}

@mixin compose-index-rules($map) {
  // !Exposes variables to the global scope,
  // so @content can access them when composing rules.
  $base-val: map-get($map, base-val);
  $ratio: map-get($map, ratio);
  $counts: map-get($map, counts);

  @for $count from 1 through $counts {
    $index-mod: $count !global;
    $index-val: index-val($base-val, $count, $ratio) !global;
    @content;
  }
}

// # Columns
//
// @global:
// $column-index
// $column-width-val
////////////////////////////////////////
////////////////////////////////////////

// Constructs column rules with a count.
@mixin column-rules($count) {
  @for $i from 1 through $count {
    // Undesirable, but expose mixin variables to the global scope
    // so @content can access them when composing rules.
    $column-index: "-" + $i !global;
    $column-width-val: 100 / ($column-count / $i) + "%" !global;
    @content;
  }
}

// # Colors
//
// @global:
// $color-name
// $color-val
////////////////////////////////////////
////////////////////////////////////////

// Constructs color rules with a map of color values.
@mixin color-rules($map) {
  @each $name, $val in $map {
    // Undesirable, but expose mixin variables to the global scope
    // so @content can access them when composing rules.
    $color-name: "-" + $name !global;
    $color-val: $val !global;
    @content;
  }
}

// # Borders
//
// @global:
// $border-width-step
// $border-width-val
////////////////////////////////////////
////////////////////////////////////////

// Constructs border-width rules with a map of border-width values.
@mixin border-width-rules($map) {
  @each $step, $val in $map {
    // Undesirable, but expose mixin variables to the global scope
    // so @content can access them when composing rules.
    $border-width-step: "-" + $step !global;
    $border-width-val: $val !global;
    @content;
  }
}
